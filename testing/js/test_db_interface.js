// Generated by CoffeeScript 1.6.3
(function() {
  var _this = this,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  exports.setUp = function(cb) {
    _this.db = require('../js-coffee/db_interface');
    _this.db({
      logType: 2
    });
    return cb();
  };

  exports.availability = {
    testRequire: function(test) {
      test.expect(1);
      test.ok(_this.db, 'DB interface loaded');
      return test.done();
    },
    testConnect: function(test) {
      test.expect(1);
      return _this.db.isConnected(function(err) {
        test.ifError(err, 'Connection failed!');
        return test.done();
      });
    },
    testNoConfig: function(test) {
      test.expect(1);
      _this.db({
        configPath: 'nonexistingconf.file'
      });
      return _this.db.isConnected(function(err) {
        test.ok(err, 'Still connected!?');
        return test.done();
      });
    },
    testWrongConfig: function(test) {
      test.expect(1);
      _this.db({
        configPath: 'testing/jsonWrongConfig.json'
      });
      return _this.db.isConnected(function(err) {
        test.ok(err, 'Still connected!?');
        return test.done();
      });
    },
    testPurgeQueue: function(test) {
      var evt;
      test.expect(2);
      evt = {
        eventid: '1',
        event: 'mail'
      };
      _this.db.pushEvent(evt);
      _this.db.purgeEventQueue();
      return _this.db.popEvent(function(err, obj) {
        test.ifError(err, 'Error during pop after purging!');
        test.strictEqual(obj, null, 'There was an event in the queue!?');
        return test.done();
      });
    }
  };

  exports.events = {
    setUp: function(cb) {
      _this.evt1 = {
        eventid: '1',
        event: 'mail'
      };
      _this.evt2 = {
        eventid: '2',
        event: 'mail'
      };
      _this.db.purgeEventQueue();
      return cb();
    },
    testEmptyPopping: function(test) {
      test.expect(2);
      return _this.db.popEvent(function(err, obj) {
        test.ifError(err, 'Error during pop after purging!');
        test.strictEqual(obj, null, 'There was an event in the queue!?');
        return test.done();
      });
    },
    testEmptyPushing: function(test) {
      test.expect(2);
      _this.db.pushEvent(null);
      return _this.db.popEvent(function(err, obj) {
        test.ifError(err, 'Error during non-empty pushing!');
        test.strictEqual(obj, null, 'There was an event in the queue!?');
        return test.done();
      });
    },
    testNonEmptyPopping: function(test) {
      test.expect(3);
      _this.db.pushEvent(_this.evt1);
      return _this.db.popEvent(function(err, obj) {
        test.ifError(err, 'Error during non-empty popping!');
        test.notStrictEqual(obj, null, 'There was no event in the queue!');
        test.deepEqual(_this.evt1, obj, 'Wrong event in queue!');
        return test.done();
      });
    },
    testMultiplePushAndPops: function(test) {
      var forkEnds, semaphore;
      test.expect(6);
      semaphore = 2;
      forkEnds = function() {
        if (--semaphore === 0) {
          return test.done();
        }
      };
      _this.db.pushEvent(_this.evt1);
      _this.db.pushEvent(_this.evt2);
      _this.db.popEvent(function(err, obj) {
        test.ifError(err, 'Error during multiple push and pop!');
        test.notStrictEqual(obj, null, 'There was no event in the queue!');
        test.deepEqual(_this.evt1, obj, 'Wrong event in queue!');
        return forkEnds();
      });
      return _this.db.popEvent(function(err, obj) {
        test.ifError(err, 'Error during multiple push and pop!');
        test.notStrictEqual(obj, null, 'There was no event in the queue!');
        test.deepEqual(_this.evt2, obj, 'Wrong event in queue!');
        return forkEnds();
      });
    }
  };

  exports.action_invoker = {
    testCreateAndRead: function(test) {
      var action, id;
      test.expect(3);
      id = 'test-action-invoker';
      action = 'unit-test action invoker content';
      _this.db.storeActionInvoker(id, action);
      return _this.db.getActionInvokerIds(function(err, obj) {
        test.ok(__indexOf.call(obj, id) >= 0, 'Expected key not in action-invokers set');
        return _this.db.getActionInvoker(id, function(err, obj) {
          test.strictEqual(obj, action, 'Retrieved Action Invoker is not what we expected');
          return _this.db.getActionInvokers(function(err, obj) {
            test.deepEqual(action, obj[id], 'Action Invoker ist not in result set');
            _this.db.deleteActionInvoker(id);
            return test.done();
          });
        });
      });
    },
    testUpdate: function(test) {
      var action, actionNew, id;
      test.expect(2);
      id = 'test-action-invoker';
      action = 'unit-test action invoker content';
      actionNew = 'unit-test action invoker new content';
      _this.db.storeActionInvoker(id, action);
      _this.db.storeActionInvoker(id, actionNew);
      return _this.db.getActionInvoker(id, function(err, obj) {
        test.strictEqual(obj, actionNew, 'Retrieved Action Invoker is not what we expected');
        return _this.db.getActionInvokers(function(err, obj) {
          test.deepEqual(actionNew, obj[id], 'Action Invoker ist not in result set');
          _this.db.deleteActionInvoker(id);
          return test.done();
        });
      });
    },
    testDelete: function(test) {
      var action, id;
      test.expect(2);
      id = 'test-action-invoker';
      action = 'unit-test action invoker content';
      _this.db.storeActionInvoker(id, action);
      _this.db.deleteActionInvoker(id);
      return _this.db.getActionInvoker(id, function(err, obj) {
        test.strictEqual(obj, null, 'Action Invoker still exists');
        return _this.db.getActionInvokerIds(function(err, obj) {
          test.ok(__indexOf.call(obj, id) < 0, 'Action Invoker key still exists in set');
          return test.done();
        });
      });
    },
    testFetchSeveral: function(test) {
      var action1, action1name, action2, action2name, fCheckInvoker, semaphore;
      test.expect(3);
      semaphore = 2;
      action1name = 'test-action-invoker_1';
      action2name = 'test-action-invoker_2';
      action1 = 'unit-test action invoker 1 content';
      action2 = 'unit-test action invoker 2 content';
      fCheckInvoker = function(modname, mod) {
        var forkEnds, myTest;
        myTest = test;
        forkEnds = function() {
          if (--semaphore === 0) {
            return myTest.done();
          }
        };
        return function(err, obj) {
          myTest.strictEqual(mod, obj, "Invoker " + modname + " does not equal the expected one");
          _this.db.deleteActionInvoker(modname);
          return forkEnds();
        };
      };
      _this.db.storeActionInvoker(action1name, action1);
      _this.db.storeActionInvoker(action2name, action2);
      return _this.db.getActionInvokerIds(function(err, obj) {
        test.ok(__indexOf.call(obj, action1name) >= 0 && __indexOf.call(obj, action2name) >= 0, 'Not all action invoker Ids in set');
        _this.db.getActionInvoker(action1name, fCheckInvoker(action1name, action1));
        return _this.db.getActionInvoker(action2name, fCheckInvoker(action2name, action2));
      });
    }
  };

  exports.action_invoker_params = {
    testCreateAndRead: function(test) {
      var actionId, params, userId;
      test.expect(2);
      userId = 'tester1';
      actionId = 'test-action-invoker_1';
      params = 'shouldn\'t this be an object?';
      _this.db.storeActionParams(actionId, userId, params);
      return _this.db.getActionParamsIds(function(err, obj) {
        var _ref;
        test.ok((_ref = actionId + ':' + userId, __indexOf.call(obj, _ref) >= 0), 'Expected key not in action-params set');
        return _this.db.getActionParams(actionId, userId, function(err, obj) {
          test.strictEqual(obj, params, 'Retrieved action params is not what we expected');
          _this.db.deleteActionParams(actionId, userId);
          return test.done();
        });
      });
    },
    testUpdate: function(test) {
      var actionId, params, paramsNew, userId;
      test.expect(1);
      userId = 'tester1';
      actionId = 'test-action-invoker_1';
      params = 'shouldn\'t this be an object?';
      paramsNew = 'shouldn\'t this be a new object?';
      _this.db.storeActionParams(actionId, userId, params);
      _this.db.storeActionParams(actionId, userId, paramsNew);
      return _this.db.getActionParams(actionId, userId, function(err, obj) {
        test.strictEqual(obj, paramsNew, 'Retrieved action params is not what we expected');
        _this.db.deleteActionParams(actionId, userId);
        return test.done();
      });
    },
    testDelete: function(test) {
      var actionId, params, userId;
      test.expect(2);
      userId = 'tester1';
      actionId = 'test-action-invoker_1';
      params = 'shouldn\'t this be an object?';
      _this.db.storeActionParams(actionId, userId, params);
      _this.db.deleteActionParams(actionId, userId);
      return _this.db.getActionParams(actionId, userId, function(err, obj) {
        test.strictEqual(obj, null, 'Action params still exists');
        return _this.db.getActionParamsIds(function(err, obj) {
          var _ref;
          test.ok((_ref = actionId + ':' + userId, __indexOf.call(obj, _ref) < 0), 'Action Params key still exists in set');
          return test.done();
        });
      });
    }
  };

  exports.event_poller = {
    testCreateAndRead: function(test) {
      var event, id;
      test.expect(3);
      id = 'test-event-poller';
      event = 'unit-test event poller content';
      _this.db.storeEventPoller(id, event);
      return _this.db.getEventPollerIds(function(err, obj) {
        test.ok(__indexOf.call(obj, id) >= 0, 'Expected key not in event-pollers set');
        return _this.db.getEventPoller(id, function(err, obj) {
          test.strictEqual(obj, event, 'Retrieved Event Poller is not what we expected');
          return _this.db.getEventPollers(function(err, obj) {
            test.deepEqual(event, obj[id], 'Event Poller ist not in result set');
            _this.db.deleteEventPoller(id);
            return test.done();
          });
        });
      });
    },
    testUpdate: function(test) {
      var event, eventNew, id;
      test.expect(2);
      id = 'test-event-poller';
      event = 'unit-test event poller content';
      eventNew = 'unit-test event poller new content';
      _this.db.storeEventPoller(id, event);
      _this.db.storeEventPoller(id, eventNew);
      return _this.db.getEventPoller(id, function(err, obj) {
        test.strictEqual(obj, eventNew, 'Retrieved Event Poller is not what we expected');
        return _this.db.getEventPollers(function(err, obj) {
          test.deepEqual(eventNew, obj[id], 'Event Poller ist not in result set');
          _this.db.deleteEventPoller(id);
          return test.done();
        });
      });
    },
    testDelete: function(test) {
      var event, id;
      test.expect(2);
      id = 'test-event-poller';
      event = 'unit-test event poller content';
      _this.db.storeEventPoller(id, event);
      _this.db.deleteEventPoller(id);
      return _this.db.getEventPoller(id, function(err, obj) {
        test.strictEqual(obj, null, 'Event Poller still exists');
        return _this.db.getEventPollerIds(function(err, obj) {
          test.ok(__indexOf.call(obj, id) < 0, 'Event Poller key still exists in set');
          return test.done();
        });
      });
    },
    testFetchSeveral: function(test) {
      var event1, event1name, event2, event2name, fCheckPoller, semaphore;
      test.expect(3);
      semaphore = 2;
      event1name = 'test-event-poller_1';
      event2name = 'test-event-poller_2';
      event1 = 'unit-test event poller 1 content';
      event2 = 'unit-test event poller 2 content';
      fCheckPoller = function(modname, mod) {
        var forkEnds, myTest;
        myTest = test;
        forkEnds = function() {
          if (--semaphore === 0) {
            return myTest.done();
          }
        };
        return function(err, obj) {
          myTest.strictEqual(mod, obj, "Invoker " + modname + " does not equal the expected one");
          _this.db.deleteEventPoller(modname);
          return forkEnds();
        };
      };
      _this.db.storeEventPoller(event1name, event1);
      _this.db.storeEventPoller(event2name, event2);
      return _this.db.getEventPollerIds(function(err, obj) {
        test.ok(__indexOf.call(obj, event1name) >= 0 && __indexOf.call(obj, event2name) >= 0, 'Not all event poller Ids in set');
        _this.db.getEventPoller(event1name, fCheckPoller(event1name, event1));
        return _this.db.getEventPoller(event2name, fCheckPoller(event2name, event2));
      });
    }
  };

  exports.event_poller_params = {
    testCreateAndRead: function(test) {
      var eventId, params, userId;
      test.expect(2);
      userId = 'tester1';
      eventId = 'test-event-poller_1';
      params = 'shouldn\'t this be an object?';
      _this.db.storeEventParams(eventId, userId, params);
      return _this.db.getEventParamsIds(function(err, obj) {
        var _ref;
        test.ok((_ref = eventId + ':' + userId, __indexOf.call(obj, _ref) >= 0), 'Expected key not in event-params set');
        return _this.db.getEventParams(eventId, userId, function(err, obj) {
          test.strictEqual(obj, params, 'Retrieved event params is not what we expected');
          _this.db.deleteEventParams(eventId, userId);
          return test.done();
        });
      });
    },
    testUpdate: function(test) {
      var eventId, params, paramsNew, userId;
      test.expect(1);
      userId = 'tester1';
      eventId = 'test-event-poller_1';
      params = 'shouldn\'t this be an object?';
      paramsNew = 'shouldn\'t this be a new object?';
      _this.db.storeEventParams(eventId, userId, params);
      _this.db.storeEventParams(eventId, userId, paramsNew);
      return _this.db.getEventParams(eventId, userId, function(err, obj) {
        test.strictEqual(obj, paramsNew, 'Retrieved event params is not what we expected');
        _this.db.deleteEventParams(eventId, userId);
        return test.done();
      });
    },
    testDelete: function(test) {
      var eventId, params, userId;
      test.expect(2);
      userId = 'tester1';
      eventId = 'test-event-poller_1';
      params = 'shouldn\'t this be an object?';
      _this.db.storeEventParams(eventId, userId, params);
      _this.db.deleteEventParams(eventId, userId);
      return _this.db.getEventParams(eventId, userId, function(err, obj) {
        test.strictEqual(obj, null, 'Event params still exists');
        return _this.db.getEventParamsIds(function(err, obj) {
          var _ref;
          test.ok((_ref = eventId + ':' + userId, __indexOf.call(obj, _ref) < 0), 'Event Params key still exists in set');
          return test.done();
        });
      });
    }
  };

  exports.rules = {
    setUp: function(cb) {
      _this.db({
        logType: 1
      });
      _this.userId = 'tester-1';
      _this.ruleId = 'test-rule_1';
      _this.rule = {
        "id": "rule_id",
        "event": "custom",
        "condition": {
          "property": "yourValue"
        },
        "actions": []
      };
      _this.ruleNew = {
        "id": "rule_new",
        "event": "custom",
        "condition": {
          "property": "yourValue"
        },
        "actions": []
      };
      return cb();
    },
    tearDown: function(cb) {
      _this.db.deleteRule(_this.ruleId);
      return cb();
    },
    testCreateAndRead: function(test) {
      test.expect(3);
      _this.db.storeRule(_this.ruleId, JSON.stringify(_this.rule));
      return _this.db.getRuleIds(function(err, obj) {
        var _ref;
        test.ok((_ref = _this.ruleId, __indexOf.call(obj, _ref) >= 0), 'Expected key not in rule key set');
        return _this.db.getRule(_this.ruleId, function(err, obj) {
          test.deepEqual(JSON.parse(obj), _this.rule, 'Retrieved rule is not what we expected');
          return _this.db.getRules(function(err, obj) {
            test.deepEqual(_this.rule, JSON.parse(obj[_this.ruleId]), 'Rule not in result set');
            _this.db.deleteRule(_this.ruleId);
            return test.done();
          });
        });
      });
    },
    testUpdate: function(test) {
      test.expect(1);
      _this.db.storeRule(_this.ruleId, JSON.stringify(_this.rule));
      _this.db.storeRule(_this.ruleId, JSON.stringify(_this.ruleNew));
      return _this.db.getRule(_this.ruleId, function(err, obj) {
        test.deepEqual(JSON.parse(obj), _this.ruleNew, 'Retrieved rule is not what we expected');
        _this.db.deleteRule(_this.ruleId);
        return test.done();
      });
    },
    testDelete: function(test) {
      test.expect(2);
      _this.db.storeRule(_this.ruleId, JSON.stringify(_this.rule));
      _this.db.deleteRule(_this.ruleId);
      return _this.db.getRule(_this.ruleId, function(err, obj) {
        test.strictEqual(obj, null, 'Rule still exists');
        return _this.db.getRuleIds(function(err, obj) {
          var _ref;
          test.ok((_ref = _this.ruleId, __indexOf.call(obj, _ref) < 0), 'Rule key still exists in set');
          return test.done();
        });
      });
    },
    testLink: function(test) {
      test.expect(2);
      _this.db.linkRule(_this.ruleId, _this.userId);
      return _this.db.getRuleLinkedUsers(_this.ruleId, function(err, obj) {
        var _ref;
        test.ok((_ref = _this.userId, __indexOf.call(obj, _ref) >= 0), "Rule not linked to user " + _this.userId);
        return _this.db.getUserLinkedRules(_this.userId, function(err, obj) {
          var _ref1;
          test.ok((_ref1 = _this.ruleId, __indexOf.call(obj, _ref1) >= 0), "User not linked to rule " + _this.ruleId);
          return test.done();
        });
      });
    },
    testUnlink: function(test) {
      test.expect(2);
      _this.db.linkRule(_this.ruleId, _this.userId);
      _this.db.unlinkRule(_this.ruleId, _this.userId);
      return _this.db.getRuleLinkedUsers(_this.ruleId, function(err, obj) {
        var _ref;
        test.ok((_ref = _this.userId, __indexOf.call(obj, _ref) < 0), "Rule still linked to user " + _this.userId);
        return _this.db.getUserLinkedRules(_this.userId, function(err, obj) {
          var _ref1;
          test.ok((_ref1 = _this.ruleId, __indexOf.call(obj, _ref1) < 0), "User still linked to rule " + _this.ruleId);
          return test.done();
        });
      });
    },
    testActivate: function(test) {
      var usr;
      test.expect(3);
      usr = {
        username: "tester-1",
        password: "tester-1"
      };
      _this.db.storeUser(usr);
      _this.db.activateRule(_this.ruleId, _this.userId);
      return _this.db.getRuleActivatedUsers(_this.ruleId, function(err, obj) {
        var _ref;
        test.ok((_ref = _this.userId, __indexOf.call(obj, _ref) >= 0), "Rule not activated for user " + _this.userId);
        return _this.db.getUserActivatedRules(_this.userId, function(err, obj) {
          var _ref1;
          test.ok((_ref1 = _this.ruleId, __indexOf.call(obj, _ref1) >= 0), "User not activated for rule " + _this.ruleId);
          return _this.db.getAllActivatedRuleIdsPerUser(function(err, obj) {
            var _ref2;
            test.ok(obj[_this.userId], "User not found in activated set");
            test.ok((_ref2 = _this.ruleId, __indexOf.call(obj[_this.userId], _ref2) >= 0), "Rule " + _this.ruleId + " not in activated rules set");
            return test.done();
          });
        });
      });
    },
    testDeactivate: function(test) {
      test.expect(3);
      _this.db.activateRule(_this.ruleId, _this.userId);
      _this.db.deactivateRule(_this.ruleId, _this.userId);
      return _this.db.getRuleActivatedUsers(_this.ruleId, function(err, obj) {
        var _ref;
        test.ok((_ref = _this.userId, __indexOf.call(obj, _ref) < 0), "Rule still activated for user " + _this.userId);
        return _this.db.getUserActivatedRules(_this.userId, function(err, obj) {
          var _ref1;
          test.ok((_ref1 = _this.ruleId, __indexOf.call(obj, _ref1) < 0), "User still activated for rule " + _this.ruleId);
          return _this.db.getAllActivatedRuleIdsPerUser(function(err, obj) {
            var _ref2;
            test.ok((_ref2 = _this.ruleId, __indexOf.call(obj[_this.userId], _ref2) < 0), "Rule " + _this.ruleId + " still in activated rules set");
            return test.done();
          });
        });
      });
    },
    testUnlinkAndDeactivateAfterDeletion: function(test) {
      var fWaitForDeletion, fWaitForTest;
      test.expect(2);
      _this.db.storeRule(_this.ruleId, JSON.stringify(_this.rule));
      _this.db.linkRule(_this.ruleId, _this.userId);
      _this.db.activateRule(_this.ruleId, _this.userId);
      fWaitForTest = function() {
        return _this.db.getUserLinkedRules(_this.userId, function(err, obj) {
          var _ref;
          test.ok((_ref = _this.ruleId, __indexOf.call(obj, _ref) < 0), "Rule " + _this.ruleId + " still linked to user " + _this.userId);
          return _this.db.getUserActivatedRules(_this.userId, function(err, obj) {
            var _ref1;
            test.ok((_ref1 = _this.ruleId, __indexOf.call(obj, _ref1) < 0), "Rule " + _this.ruleId + " still activated for user " + _this.userId);
            return test.done();
          });
        });
      };
      fWaitForDeletion = function() {
        _this.db.deleteRule(_this.ruleId);
        return setTimeout(fWaitForTest, 100);
      };
      return setTimeout(fWaitForDeletion, 100);
    }
  };

  exports.tearDown = function(cb) {
    _this.db.shutDown();
    return cb();
  };

}).call(this);
