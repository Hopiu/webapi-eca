// Generated by CoffeeScript 1.6.3
(function() {
  var _this = this,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  exports.setUp = function(cb) {
    _this.log = require('../js-coffee/logging');
    _this.db = require('../js-coffee/db_interface');
    _this.db({
      logType: 2
    });
    return cb();
  };

  exports.availability = {
    testRequire: function(test) {
      test.expect(1);
      test.ok(_this.db, 'DB interface loaded');
      return test.done();
    },
    testConnect: function(test) {
      test.expect(1);
      return _this.db.isConnected(function(err) {
        test.ifError(err, 'Connection failed!');
        return test.done();
      });
    },
    testNoConfig: function(test) {
      test.expect(1);
      _this.db({
        configPath: 'nonexistingconf.file'
      });
      return _this.db.isConnected(function(err) {
        test.ok(err, 'Still connected!?');
        return test.done();
      });
    },
    testWrongConfig: function(test) {
      test.expect(1);
      _this.db({
        configPath: 'testing/jsonWrongConfig.json'
      });
      return _this.db.isConnected(function(err) {
        test.ok(err, 'Still connected!?');
        return test.done();
      });
    },
    testPurgeQueue: function(test) {
      var evt;
      evt = {
        eventid: '1',
        event: 'mail'
      };
      test.expect(2);
      _this.db.pushEvent(evt);
      _this.db.purgeEventQueue();
      return _this.db.popEvent(function(err, obj) {
        test.ifError(err, 'Error during pop after purging!');
        test.strictEqual(obj, null, 'There was an event in the queue!?');
        return test.done();
      });
    }
  };

  exports.events = {
    setUp: function(cb) {
      _this.evt1 = {
        eventid: '1',
        event: 'mail'
      };
      _this.evt2 = {
        eventid: '2',
        event: 'mail'
      };
      _this.db.purgeEventQueue();
      return cb();
    },
    testEmptyPopping: function(test) {
      test.expect(2);
      return _this.db.popEvent(function(err, obj) {
        test.ifError(err, 'Error during pop after purging!');
        test.strictEqual(obj, null, 'There was an event in the queue!?');
        return test.done();
      });
    },
    testEmptyPushing: function(test) {
      test.expect(2);
      _this.db.pushEvent(null);
      return _this.db.popEvent(function(err, obj) {
        test.ifError(err, 'Error during non-empty pushing!');
        test.strictEqual(obj, null, 'There was an event in the queue!?');
        return test.done();
      });
    },
    testNonEmptyPopping: function(test) {
      test.expect(3);
      _this.db.pushEvent(_this.evt1);
      return _this.db.popEvent(function(err, obj) {
        test.ifError(err, 'Error during non-empty popping!');
        test.notStrictEqual(obj, null, 'There was no event in the queue!');
        test.deepEqual(_this.evt1, obj, 'Wrong event in queue!');
        return test.done();
      });
    },
    testMultiplePushAndPops: function(test) {
      var forkEnds, semaphore;
      test.expect(6);
      semaphore = 2;
      forkEnds = function() {
        if (--semaphore === 0) {
          return test.done();
        }
      };
      _this.db.pushEvent(_this.evt1);
      _this.db.pushEvent(_this.evt2);
      _this.db.popEvent(function(err, obj) {
        test.ifError(err, 'Error during multiple push and pop!');
        test.notStrictEqual(obj, null, 'There was no event in the queue!');
        test.deepEqual(_this.evt1, obj, 'Wrong event in queue!');
        return forkEnds();
      });
      return _this.db.popEvent(function(err, obj) {
        test.ifError(err, 'Error during multiple push and pop!');
        test.notStrictEqual(obj, null, 'There was no event in the queue!');
        test.deepEqual(_this.evt2, obj, 'Wrong event in queue!');
        return forkEnds();
      });
    }
  };

  exports.action_modules = {
    testModule: function(test) {
      var action1, action1name, fCheckModuleExists, fCheckModuleNotExists, fCheckModuleNotExistsInSet, fCheckSetEntry;
      test.expect(4);
      action1name = 'test-action-module_1';
      action1 = 'unit-test action module 1 content';
      fCheckSetEntry = function(err, obj) {
        test.ok(__indexOf.call(obj, action1name) >= 0, 'Expected key not in action-modules set');
        return _this.db.getActionModule(action1name, fCheckModuleExists);
      };
      fCheckModuleExists = function(err, obj) {
        test.strictEqual(obj, action1, 'Retrieved Action Module is not what we expected');
        _this.log.print('delete action module');
        _this.db.deleteActionModule(action1name);
        _this.log.print('tried to delete action module');
        return _this.db.getActionModule(action1name, fCheckModuleNotExists);
      };
      fCheckModuleNotExists = function(err, obj) {
        _this.log.print('got action module');
        test.strictEqual(obj, null, 'Action module still exists');
        _this.log.print('compared action module');
        return _this.db.getActionModuleIds(fCheckModuleNotExistsInSet);
      };
      fCheckModuleNotExistsInSet = function(err, obj) {
        test.ok(__indexOf.call(obj, action1name) < 0, 'Action module key still exists in set');
        return test.done();
      };
      _this.db.storeActionModule(action1name, action1);
      return _this.db.getActionModuleIds(fCheckSetEntry);
    },
    testFetchSeveralModules: function(test) {
      var action1, action1name, action2, action2name, fCheckModule, fCheckSetEntries, forkEnds, semaphore;
      semaphore = 2;
      forkEnds = function() {
        if (--semaphore === 0) {
          return test.done();
        }
      };
      test.expect(3);
      action1name = 'test-action-module_1';
      action2name = 'test-action-module_2';
      action1 = 'unit-test action module 1 content';
      action2 = 'unit-test action module 2 content';
      fCheckModule = function(mod) {
        var myTest;
        myTest = test;
        console.log('check module');
        return function(err, obj) {
          console.log('db answered');
          myTest.strictEqual(mod, obj, "Module does not equal the expected one");
          return forkEnds();
        };
      };
      fCheckSetEntries = function(err, obj) {
        test.ok(__indexOf.call(obj, action1name) >= 0 && __indexOf.call(obj, action2name) >= 0, 'Not all action module Ids in set');
        console.log('setentries fetched');
        this.db.getActionModule(action1name, fCheckModule(action1));
        return this.db.getActionModule(action2name, fCheckModule(action2));
      };
      _this.db.storeActionModule(action1name, action1);
      _this.db.storeActionModule(action2name, action2);
      return _this.db.getActionModuleIds(fCheckSetEntries);
    }
  };

  exports.tearDown = function(cb) {
    _this.db.shutDown();
    return cb();
  };

}).call(this);
