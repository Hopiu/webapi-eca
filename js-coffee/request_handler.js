// Generated by CoffeeScript 1.6.3
/*

Request Handler
============
> TODO Add documentation
*/


(function() {
  var answerHandler, crypto, db, exports, fs, getHandlerFileAsString, getHandlerPath, log, mm, mustache, objAdminCmds, objUserCmds, path, qs, renderPage, sendLoginOrPage,
    _this = this;

  log = require('./logging');

  db = require('./db_interface');

  mm = require('./module_manager');

  fs = require('fs');

  path = require('path');

  qs = require('querystring');

  mustache = require('mustache');

  crypto = require('crypto-js');

  objAdminCmds = {
    'loadrules': mm.loadRulesFromFS,
    'loadaction': mm.loadActionModuleFromFS,
    'loadactions': mm.loadActionModulesFromFS,
    'loadevent': mm.loadEventModuleFromFS,
    'loadevents': mm.loadEventModulesFromFS
  };

  objUserCmds = {
    'store_action': mm.storeActionModule,
    'get_actionmodules': mm.getAllActionModules,
    'store_event': mm.storeEventModule,
    'get_eventmodules': mm.getAllEventModules,
    'store_rule': mm.storeRule
  };

  exports = module.exports = function(args) {
    var user, users, _i, _len;
    args = args != null ? args : {};
    log(args);
    db(args);
    mm(args);
    mm.addDBLink(db);
    users = JSON.parse(fs.readFileSync(path.resolve(__dirname, '..', 'config', 'users.json')));
    for (_i = 0, _len = users.length; _i < _len; _i++) {
      user = users[_i];
      db.storeUser(user);
    }
    return module.exports;
  };

  /*
  This allows the parent to add handlers. The event handler will receive
  the events that were received. The shutdown function will be called if the
  admin command shutdown is issued.
  
  @public addHandlers( *fShutdown* )
  @param {function} fShutdown
  */


  exports.addHandlers = function(fShutdown) {
    return objAdminCmds.shutdown = function(args, answerHandler) {
      answerHandler.answerSuccess('Shutting down... BYE!');
      return setTimeout(fShutdown, 500);
    };
  };

  /*
  Handles possible events that were posted to this server and pushes them into the
  event queue.
  
  *Requires
  the [request](http://nodejs.org/api/http.html#http_class_http_clientrequest)
  and [response](http://nodejs.org/api/http.html#http_class_http_serverresponse)
  objects.*
  
  @public handleEvent( *req, resp* )
  */


  exports.handleEvent = function(req, resp) {
    var body;
    body = '';
    req.on('data', function(data) {
      return body += data;
    });
    return req.on('end', function() {
      var obj;
      obj = qs.parse(body);
      if (obj && obj.event && obj.eventid) {
        resp.send('Thank you for the event: ' + obj.event + ' (' + obj.eventid + ')!');
        return db.pushEvent(obj);
      } else {
        return resp.send(400, 'Your event was missing important parameters!');
      }
    });
  };

  /*
  
  *Requires
  the [request](http://nodejs.org/api/http.html#http_class_http_clientrequest)
  and [response](http://nodejs.org/api/http.html#http_class_http_serverresponse)
  objects.*
  
  @public handleLogin( *req, resp* )
  */


  exports.handleLogin = function(req, resp) {
    var body;
    body = '';
    req.on('data', function(data) {
      return body += data;
    });
    return req.on('end', function() {
      var obj;
      if (!req.session || !req.session.user) {
        obj = qs.parse(body);
        return db.loginUser(obj.username, obj.password, function(err, usr) {
          if (err) {
            log.print('RH', ("AUTH-UH-OH (" + obj.username + "): ") + err.message);
          } else {
            req.session.user = usr;
          }
          if (req.session.user) {
            return resp.send('OK!');
          } else {
            return resp.send(401, 'NO!');
          }
        });
      } else {
        return resp.send('Welcome ' + req.session.user.name + '!');
      }
    });
  };

  /*
  A post request retrieved on this handler causes the user object to be
  purged from the session, thus the user will be logged out.
  
  *Requires
  the [request](http://nodejs.org/api/http.html#http_class_http_clientrequest)
  and [response](http://nodejs.org/api/http.html#http_class_http_serverresponse)
  objects.*
  
  @public handleLogout( *req, resp* )
  */


  exports.handleLogout = function(req, resp) {
    if (req.session) {
      req.session.user = null;
      return resp.send('Bye!');
    }
  };

  /*
  Resolves the path to a handler webpage.
  
  @private getHandlerPath( *name* )
  @param {String} name
  */


  getHandlerPath = function(name) {
    return path.resolve(__dirname, '..', 'webpages', 'handlers', name + '.html');
  };

  /*
  Resolves the path to a handler webpage and returns it as a string.
  
  @private getHandlerFileAsString( *name* )
  @param {String} name
  */


  getHandlerFileAsString = function(name) {
    return fs.readFileSync(getHandlerPath(name), 'utf8');
  };

  /*
  Renders a page depending on the user session and returns it.
  
  @private renderPage( *name, sess* )
  @param {String} name
  @param {Object} sess
  */


  renderPage = function(name, sess, msg) {
    var menubar, requires, template, view;
    template = getHandlerFileAsString(name);
    menubar = getHandlerFileAsString('part_menubar');
    requires = getHandlerFileAsString('part_requires');
    view = {
      user: sess.user,
      head_requires: requires,
      div_menubar: menubar,
      message: msg
    };
    return mustache.render(template, view);
  };

  /*
  Sends the desired page or the login to the user.
  
  *Requires
  the [request](http://nodejs.org/api/http.html#http_class_http_clientrequest)
  and [response](http://nodejs.org/api/http.html#http_class_http_serverresponse)
  objects.*
  
  @public renderPageOrLogin( *req, resp, pagename* )
  @param {String} pagename
  */


  sendLoginOrPage = function(pagename, req, resp) {
    if (req.session && req.session.user) {
      return resp.send(renderPage(pagename, req.session));
    } else {
      return resp.sendfile(getHandlerPath('login'));
    }
  };

  /*
  Present the module forge to the user.
  
  *Requires
  the [request](http://nodejs.org/api/http.html#http_class_http_clientrequest)
  and [response](http://nodejs.org/api/http.html#http_class_http_serverresponse)
  objects.*
  
  @public handleForgeModules( *req, resp* )
  */


  exports.handleForgeModules = function(req, resp) {
    return sendLoginOrPage('forge_modules', req, resp);
  };

  /*
  Present the rules forge to the user.
  
  *Requires
  the [request](http://nodejs.org/api/http.html#http_class_http_clientrequest)
  and [response](http://nodejs.org/api/http.html#http_class_http_serverresponse)
  objects.*
  
  @public handleForgeRules( *req, resp* )
  */


  exports.handleForgeRules = function(req, resp) {
    return sendLoginOrPage('forge_rules', req, resp);
  };

  /*
  Present the event invoke page to the user.
  
  *Requires
  the [request](http://nodejs.org/api/http.html#http_class_http_clientrequest)
  and [response](http://nodejs.org/api/http.html#http_class_http_serverresponse)
  objects.*
  
  @public handleInvokeEvent( *req, resp* )
  */


  exports.handleInvokeEvent = function(req, resp) {
    return sendLoginOrPage('push_event', req, resp);
  };

  /*
  Handles the user command requests.
  
  *Requires
  the [request](http://nodejs.org/api/http.html#http_class_http_clientrequest)
  and [response](http://nodejs.org/api/http.html#http_class_http_serverresponse)
  objects.*
  
  @public handleUser( *req, resp* )
  */


  exports.handleUserCommand = function(req, resp) {
    var body;
    if (!req.session || !req.session.user) {
      return resp.send(401, 'Login first!');
    } else {
      body = '';
      req.on('data', function(data) {
        return body += data;
      });
      return req.on('end', function() {
        var obj;
        obj = qs.parse(body);
        console.log(obj);
        if (typeof objUserCmds[obj.command] === 'function') {
          return objUserCmds[obj.command](req.session.user, obj, answerHandler(req, resp));
        } else {
          return resp.send(404, 'Command unknown!');
        }
      });
    }
  };

  /*
  Handles the admin command requests.
  
  *Requires
  the [request](http://nodejs.org/api/http.html#http_class_http_clientrequest)
  and [response](http://nodejs.org/api/http.html#http_class_http_serverresponse)
  objects.*
  
  @public handleAdmin( *req, resp* )
  */


  exports.handleAdmin = function(req, resp) {
    var q, _name;
    if (req.session && req.session.user) {
      if (req.session.user.isAdmin === "true") {
        q = req.query;
        log.print('RH', 'Received admin request: ' + req.originalUrl);
        if (q.cmd) {
          return typeof objAdminCmds[_name = q.cmd] === "function" ? objAdminCmds[_name](q, answerHandler(req, resp, true)) : void 0;
        } else {
          return resp.send(404, 'Command unknown!');
        }
      } else {
        return resp.send(renderPage('unauthorized', req.session));
      }
    } else {
      return resp.sendfile(getHandlerPath('login'));
    }
  };

  answerHandler = function(req, resp, ntbr) {
    var hasBeenAnswered, needsToBeRendered, request, response, ret;
    request = req;
    response = resp;
    needsToBeRendered = ntbr;
    hasBeenAnswered = false;
    ret = {
      answerSuccess: function(msg) {
        if (!hasBeenAnswered) {
          if (needsToBeRendered) {
            response.send(renderPage('command_answer', request.session, msg));
          } else {
            response.send(msg);
          }
        }
        return hasBeenAnswered = true;
      },
      answerError: function(msg) {
        if (!hasBeenAnswered) {
          if (needsToBeRendered) {
            response.send(400, renderPage('error', request.session, msg));
          } else {
            response.send(400, msg);
          }
        }
        return hasBeenAnswered = true;
      },
      isAnswered: function() {
        return hasBeenAnswered;
      }
    };
    setTimeout(function() {
      return ret.answerError('Strange... maybe try again?');
    }, 5000);
    return ret;
  };

}).call(this);
